## Testing notes

### RSAUtils

My first task was to ensure the Swift functions to load RSA private keys and sign chunks of data produce the same output as the functions used in the Python implementation. Here's a Python script that calls `rsa.PrivateKey.load_pkcs1` and `rsa.sign` (as does the Python implementation)

```python
import base64
import rsa

keyData = """-----BEGIN RSA PRIVATE KEY-----
MIIEpAIBAAKCAQEA4XZhFX3V4NFUQbZdWmDPEN5KJeRVm9bOJUigDRyD2UfdZbpd
Hy1lddomfxziRlJhuSTEsKBANhdiEv8rkHghtwIlpzzbROMkkbYHZETileAWy4tn
qHtgCBtVvwMU8Rjza9eUJzDdzC/fT7zYcYbAdT8R3Er55A18J8jDuBMzmMQEnNbL
oSIMP5ISPd5bPzG/3gdHsEvLuHweWhGCi1gvfaB6/mssng/wlQOHm6P8NPBcmWAW
gSVyF7xafCQsaS/0GnzhfZCjvTwMiCtoqEkvCQMdMd9yRFSoPm8V85tKRpfnPxOu
3+W2BXnILIg03RdAY9ZLUj7l0FyPTs/BLFqdIwIDAQABAoIBAQCHcR/9UyzK87WU
DEOkaYe68G7GuJadGbuZNjm/5qNmQf/EfuI2OoU6+SQrNGTSLec629W07W/ljsKB
+vxmu2Q1lnqcLrjidzmetyVVnPQpaQcIm+RXmFYmSJWIPAe2lnCVFlqP+JElepTC
SAYWnQa86HiISBo6X8d39ulsiUxzthyL2sHz2FBDyGfXifMi53Xze4C8tqk0jqxc
bTZTquUoPwmn4CNt65vQv5TWyeDeu0M+nHkoemZvtJ2b8/l3C1KjjqSHgODHqhg7
69PInOv9PFKTe6nh38+ARRKbGkQQ25JuULl8WVDMDXVitAb91PPHDSjpH2/towEG
ORvIbVvxAoGBAP8XLy9YrZDaNYGBHivqTDOLFMNFXl2V2UxwsvsRimc/qKHGKv5A
EorzRJ/DJNfNaq4WY+eH/yMtcyD3QAJ5BMgsv6FjpJii7dg3BnQdu+DGSfA5skv5
x6HsUAhCBI2W+rpfLLn6Hwz5VQ2a5/Z1rp/Fa4MMusXtm9/fpKDEY6JFAoGBAOJE
J2kARshHpCV5Tx3Vp1CCOTJyZWnL+P857IYkweCeYnnIzPnTx+JEi0d3v8PxkUuP
Ctq8G5zC6eC0mH4V9J5QOr8UVXVp5v+sX3CaubNEog3m9NfCETW1uLZ7ca2/yASP
dbY/D9tn/rF9jOGuMb/lOOi3fPcOfq52wy3RLexHAoGBANgN9vUPEtLhPvhVOAzS
AYCWiBtsIaT6SnYn7jAghy00CcwbYEbAVfRCXxlB2268mWKhrDRqR3qwABcn05tE
jPxOinBTSRHOzcyXrmui04Jp8C37cDxRbviCgra708do3SwFeIh8hNgkRhmj3lwt
CJ5iQ9FXcso5mhBgB7vzGsBRAoGAeCyqoeI7tfQXArBDjR0FGIWRy3Fm26IyRZyG
O1kagCqfMv+rnqUU7OBq+TJo77FF8lOu+C4gnEoJ3gcNVypiGhOSoBo0qX/t6K2s
oyoKp2Q0jh20vUOd0GEMEh/OaPILUiC/7GPiEC5T4AFG6jaSxdEBQNjzzmQsdI0v
bQ5EzdECgYBAyQe6+LA6PPp19T15zR52yI3A2GCxhnWo85j3J0DBSMfTJkqTkZ8A
qetlov0aId57N48fco3Uno1zybEzUxFMCi7x/04xNY8TpMsPSzHpqgIuGVVtBBz/
YgobcZkFwOQZ+omcKfbH7qs7U8cZ2+eKE+hjUR/+DCH5UEMwUohbAw==
-----END RSA PRIVATE KEY-----"""

key = rsa.PrivateKey.load_pkcs1(keyData.encode('utf8'))
message = "Hello, World!".encode('utf8')
signature = rsa.sign(message, key, "SHA-1")
print(base64.b64encode(signature))
```

When run, it produces the following output:

```
b'i+W2UtxTiYXoL/yeeYgGtQ4knoedWBS7DND0FUjL1usZIx6pwzqvxegwssuEvPRgWq+SQqXJT5ikX0ARNBzHU7ve/kg0TGjWNK0ZvtyXdoExpNnEI/u3glVcovMt8oGa4xr4RvWLyU57bdxvbkYIG0bsiMpD4mUffg7dxxguf7WQ7Be0+VkAByL/KJFyDl+oOTxqckuQJ27pPZrESeH46XA6YpsG/mcsTIXkXqSKd5NQ0cIEWHeQ8LL3yIafMQ5rSQCxWy54GJ38qD74O6e4aqJ5rtWbGWGl7bjgNPjgom+ECC1uKMP0NJT0S61NPETsxkYygxjrtdweio4WEwpABA=='
```

This is used in the test `signDataWithPrivateKeyGeneratesExpected()` to ensure the Swift signing code generates the same signature.

### CloudFrontMiddleware

Next we needed to ensure the signed URL generated by the Swift code matched that generated by the Python implementation. I used a lightly-modified version of the Python script to generate several expected values I could then test for with the Swoft implementation.
That Python script is here:

```python
import os
import time
import json
import base64
import objc
import six

from Foundation import CFPreferencesCopyAppValue, NSData

PYTHONTHREE = six.PY3

if PYTHONTHREE:
    # Py3 imports
    from rsa import PrivateKey
    from rsa import sign
else:
    # Py2 imports
    from string import maketrans
    from OpenSSL.crypto import FILETYPE_PEM
    from OpenSSL.crypto import load_privatekey
    from OpenSSL.crypto import sign

__version__ = '2.0'

BUNDLE = 'com.github.aaronburchfield.cloudfront'
CERT_PREFERENCE_NAME = 'cloudfront_certificate'
KEYFILENAME = 'munkiaccess.pem'
KEYFILEPATH = os.path.abspath(os.path.join(os.path.dirname(__file__),
                                           KEYFILENAME))


def read_preference(key, bundle):
    """Read a preference key from a preference domain."""
    value = CFPreferencesCopyAppValue(key, bundle)
    return value


def private_key_from_pref_data(pref_cert):
    """Load private key from NSData."""
    if PYTHONTHREE:
        private_key = PrivateKey.load_pkcs1(bytes(pref_cert))
    else:
        private_key = load_privatekey(FILETYPE_PEM, str(pref_cert))

    return private_key


def private_key_from_pref(pref_cert):
    """Load private key from string."""
    if PYTHONTHREE:
        private_key = PrivateKey.load_pkcs1(base64.b64decode(pref_cert))
    else:
        private_key = load_privatekey(FILETYPE_PEM, base64.b64decode(pref_cert))

    return private_key


def private_key_from_file(key_file):
    """Load private key from file path."""
    with open(key_file, 'r') as f:
        data = f.read()

    if PYTHONTHREE:
        private_key = PrivateKey.load_pkcs1(data.encode('utf8'))
    else:
        private_key = load_privatekey(FILETYPE_PEM, data)

    return private_key


def sign_request_policy(key, request_policy):
    """Return a request policy signature."""
    if PYTHONTHREE:
        request_policy = request_policy.encode('utf8')
        signature = base64.b64encode(sign(request_policy, key, 'SHA-1'))
        signature = signature.decode('utf-8')
        translation = str.maketrans('+=/', '-_~')
    else:
        signature = base64.b64encode(sign(key, request_policy, 'RSA-SHA1'))
        translation = maketrans('+=/', '-_~')

    return signature.translate(translation)


def assemble_cloudfront_request(resource, key, access_id, expires):
    """Assemble a CloudFront request."""
    # Format a request policy for the resource
    request_policy = {
        "Statement": [{"Resource": resource, "Condition": {"DateLessThan":
                      {"AWS:EpochTime": expires}}}]
    }
    request_policy = json.dumps(request_policy).replace(' ', '')
    # Sign and encode request policy
    signature = sign_request_policy(key, request_policy)
    # Format the final request URL
    cloudfront_request = ("{0}?Expires={1}&Signature={2}&Key-Pair-Id={3}"
                          .format(resource, expires, signature, access_id))
    return cloudfront_request


def generate_cloudfront_url(url):
    """Read the required components to build a CloudFront request."""
    # Read our CloudFront key from preference (preferred) or file (fallback)
    pref_cert = read_preference(CERT_PREFERENCE_NAME, BUNDLE)
    if pref_cert and isinstance(pref_cert, NSData):
        key = private_key_from_pref_data(pref_cert)
    elif pref_cert and isinstance(pref_cert, objc.pyobjc_unicode):
        # If we have a string type decode the base64 blob
        key = private_key_from_pref(pref_cert)
    else:
        key = private_key_from_file(KEYFILEPATH)
    # Read CloudFront access key id and resource expiration from preference
    access_id = read_preference('access_id', BUNDLE)
    expire_after = read_preference('expire_after', BUNDLE) or 60
    expires = int(time.time()) + 60 * int(expire_after)
    cloudfront_url = assemble_cloudfront_request(url, key, access_id, expires)
    return cloudfront_url


def process_request_options(options):
    """Return a signed request for CloudFront resources."""
    domain_name = read_preference('domain_name', BUNDLE) or 'cloudfront.net'
    if domain_name in options['url']:
        options['url'] = generate_cloudfront_url(options['url'])
    return options


PRIVATE_KEY_DATA = """-----BEGIN RSA PRIVATE KEY-----
MIIEpAIBAAKCAQEA4XZhFX3V4NFUQbZdWmDPEN5KJeRVm9bOJUigDRyD2UfdZbpd
Hy1lddomfxziRlJhuSTEsKBANhdiEv8rkHghtwIlpzzbROMkkbYHZETileAWy4tn
qHtgCBtVvwMU8Rjza9eUJzDdzC/fT7zYcYbAdT8R3Er55A18J8jDuBMzmMQEnNbL
oSIMP5ISPd5bPzG/3gdHsEvLuHweWhGCi1gvfaB6/mssng/wlQOHm6P8NPBcmWAW
gSVyF7xafCQsaS/0GnzhfZCjvTwMiCtoqEkvCQMdMd9yRFSoPm8V85tKRpfnPxOu
3+W2BXnILIg03RdAY9ZLUj7l0FyPTs/BLFqdIwIDAQABAoIBAQCHcR/9UyzK87WU
DEOkaYe68G7GuJadGbuZNjm/5qNmQf/EfuI2OoU6+SQrNGTSLec629W07W/ljsKB
+vxmu2Q1lnqcLrjidzmetyVVnPQpaQcIm+RXmFYmSJWIPAe2lnCVFlqP+JElepTC
SAYWnQa86HiISBo6X8d39ulsiUxzthyL2sHz2FBDyGfXifMi53Xze4C8tqk0jqxc
bTZTquUoPwmn4CNt65vQv5TWyeDeu0M+nHkoemZvtJ2b8/l3C1KjjqSHgODHqhg7
69PInOv9PFKTe6nh38+ARRKbGkQQ25JuULl8WVDMDXVitAb91PPHDSjpH2/towEG
ORvIbVvxAoGBAP8XLy9YrZDaNYGBHivqTDOLFMNFXl2V2UxwsvsRimc/qKHGKv5A
EorzRJ/DJNfNaq4WY+eH/yMtcyD3QAJ5BMgsv6FjpJii7dg3BnQdu+DGSfA5skv5
x6HsUAhCBI2W+rpfLLn6Hwz5VQ2a5/Z1rp/Fa4MMusXtm9/fpKDEY6JFAoGBAOJE
J2kARshHpCV5Tx3Vp1CCOTJyZWnL+P857IYkweCeYnnIzPnTx+JEi0d3v8PxkUuP
Ctq8G5zC6eC0mH4V9J5QOr8UVXVp5v+sX3CaubNEog3m9NfCETW1uLZ7ca2/yASP
dbY/D9tn/rF9jOGuMb/lOOi3fPcOfq52wy3RLexHAoGBANgN9vUPEtLhPvhVOAzS
AYCWiBtsIaT6SnYn7jAghy00CcwbYEbAVfRCXxlB2268mWKhrDRqR3qwABcn05tE
jPxOinBTSRHOzcyXrmui04Jp8C37cDxRbviCgra708do3SwFeIh8hNgkRhmj3lwt
CJ5iQ9FXcso5mhBgB7vzGsBRAoGAeCyqoeI7tfQXArBDjR0FGIWRy3Fm26IyRZyG
O1kagCqfMv+rnqUU7OBq+TJo77FF8lOu+C4gnEoJ3gcNVypiGhOSoBo0qX/t6K2s
oyoKp2Q0jh20vUOd0GEMEh/OaPILUiC/7GPiEC5T4AFG6jaSxdEBQNjzzmQsdI0v
bQ5EzdECgYBAyQe6+LA6PPp19T15zR52yI3A2GCxhnWo85j3J0DBSMfTJkqTkZ8A
qetlov0aId57N48fco3Uno1zybEzUxFMCi7x/04xNY8TpMsPSzHpqgIuGVVtBBz/
YgobcZkFwOQZ+omcKfbH7qs7U8cZ2+eKE+hjUR/+DCH5UEMwUohbAw==
-----END RSA PRIVATE KEY-----"""

# test sign_request_policy
key = PrivateKey.load_pkcs1(PRIVATE_KEY_DATA.encode('utf8'))
request_policy = "FOO_BAR_BAZ"
print("sign_request_policy result:")
print(sign_request_policy(key, request_policy))
print()

# test json encoding of policy request
def make_json_policy_request(resource, expires):
    request_policy = {
        "Statement": [{"Resource": resource, "Condition": {"DateLessThan":
                      {"AWS:EpochTime": expires}}}]
    }
    return json.dumps(request_policy).replace(' ', '')

url = "https://example.com"
expires = 1747270308
print("make_json_policy_request result:")
print(make_json_policy_request(url, expires))
print()

# test assemble_cloudfront_request
access_id = "FOO"
print("assemble_cloudfront_request result:")
print(assemble_cloudfront_request(url, key, access_id, expires))
print()
```

When run, it produces:

```
sign_request_policy result:
2AX-VxZP-D4SDZRTFPKYuMuFFiWT6oxMiZnrx4bdd9SgxWGl-JfeS1YoO4l2l~Hmf26WigIW2P~Deypbecc86qCexQrhs1dRQ1mBm4C1FSXPBCIyXUTK~MAR7EjP-iSElGSBNK3J3B7q8PT-ykieLJsB5ZbBKtw7~wmAGeng6HwHIXSnBLEqBzCSzZobuICv7f3xVNumxHF6Ibolz4uhk0jgEK7-GaikcumIVizAjrtEVY3BEQgje6t1SJeP0HxMqp1~9QH8yu95TMWXyEISvvpeBETxWm7rIyjrugU0J4f~Y2plgnV3yZA0iyeS7sACcUtm-rOJzO9VpmbBZQXuhg__

make_json_policy_request result:
{"Statement":[{"Resource":"https://example.com","Condition":{"DateLessThan":{"AWS:EpochTime":1747270308}}}]}

assemble_cloudfront_request result:
https://example.com?Expires=1747270308&Signature=mCHEo~swKdxn9mJfAXi5vodA9-H8XrO5ca8NPrFmQA8crmxgaJqlvl2gOAiECVLbTVFdQeiUtnHK2blvC2edEws8IkemkFhA2hJT4HdpnUWj1uD~JQq8qaqTL1ZmC2ohZQekueajS-ZgJdMGgaumd7iyCFBhxrimOZE-B~iZbE8vxLe-6JuKv2~RXfIaNYBEfQInAJxEpgHXwseKTSaVOFLGp804dgK1QjEM3sQi~LN~2vUrvO73JgqIgq85S6raMhvxD7qPZKfTgngFpT2iWP-x21g7Zvh6Pc9K47Iw4bQeysGZj5UFPZ0Sci5vnvJw9qFu9WDvkCh8iWyh-~b0gg__&Key-Pair-Id=FOO
```

The output values were then used as expcted values to test for in the Swift testing.
